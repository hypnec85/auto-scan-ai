AttributeError: 'dict' object has no attribute 'empty'
Traceback:
File "D:\Google Drive\Colab Notebooks\backup\study\(202511)usedcar\app.py", line 133, in <module>
    if not st.session_state.df.empty:

원인 분석:
  Streamlit의 st.data_editor는 사용자가 데이터를 수정하면 key로 지정된 세션 상태 변수(st.session_state.editor)에 수정된 데이터를 딕셔너리(dict) 형태로 저장할 수 있습니다(특히 행 추가/삭제 등의 변경     
  사항이 있을 때). 하지만 Pandas DataFrame은 딕셔너리가 아닙니다.

  update_data 함수에서 st.session_state.df = st.session_state.editor를 실행할 때, st.session_state.editor가 DataFrame이 아닌 딕셔너리 형태로 반환되는 경우가 있어 st.session_state.df가 딕셔너리로        
  덮어씌워졌고, 이후 st.session_state.df.empty를 호출할 때 딕셔너리에는 .empty 속성이 없으므로 에러가 발생한 것입니다.

  그러나 st.data_editor의 반환값 자체는 항상 수정된 DataFrame입니다. 문제는 key에 저장된 상태값(st.session_state.editor)이 내부적으로 어떻게 관리되느냐인데, 일반적으로 st.data_editor를 key와 함께 사용할
  때 on_change 콜백 시점에서는 st.session_state[key]에 변경된 데이터(DataFrame)가 들어있어야 합니다.

  하지만 Streamlit 버전에 따라 동작이 다를 수 있고, 특히 on_change 콜백 내에서 st.session_state.editor를 직접 df에 할당하는 방식이 불안정할 수 있습니다.

  가장 확실한 해결책은 on_change 콜백을 사용하는 대신, st.data_editor가 반환하는 수정된 DataFrame을 직접 변수에 할당하고, 그 변수를 사용하여 st.session_state.df를 업데이트하는 것입니다. 하지만
  on_change를 사용해야 즉각적인 반영이 보장되므로, 콜백 함수 내에서 타입 검사를 하거나, st.data_editor의 리턴값을 활용하는 구조로 다시 변경해야 합니다.

  여기서는 update_data 콜백을 제거하고, st.data_editor의 반환값을 st.session_state.df에 할당하는 이전 방식(조건문 없이 바로 할당)으로 돌아가되, key를 df 자체와 분리하여 순환 참조 문제를 방지하는 것이   
  좋습니다. 혹은 st.data_editor의 on_change를 사용할 때는 st.session_state["editor"]가 DataFrame임을 보장해야 합니다.

  사실 가장 간단하고 확실한 수정 방법은 update_data 콜백 함수를 제거하고, edited_df (data_editor의 리턴값)를 `st.session_state.df에 바로 할당하는 것입니다. 앞서 "조건문(if not edited_df.equals...`)     
  때문에 데이터가 손실된다"고 하셨으므로, 조건문 없이 할당하면 됩니다.

  수정 계획:
   1. update_data 함수 제거.
   2. st.data_editor의 on_change 파라미터 제거.
   3. st.data_editor 호출 후, 리턴값 edited_df를 st.session_state.df에 무조건 할당.

  이렇게 하면 사용자가 입력할 때마다(Rerun 될 때마다) st.session_state.df가 최신 edited_df로 갱신되어 데이터 손실을 막을 수 있습니다.

  하지만 잠깐, key="editor"를 사용하고 있으니 st.session_state.editor에 데이터가 저장됩니다. 이 st.session_state.editor가 딕셔너리로 변하는 경우가 있는지 확인해봐야 합니다. 보통은 DataFrame입니다.      

  아마도 load_csv_file_callback 등 다른 곳에서 st.session_state.df가 딕셔너리로 잘못 변환되었거나 초기화되었을 가능성도 배제할 수 없지만, 로그를 보면 app.py 133라인(if not
  st.session_state.df.empty:)에서 에러가 났습니다. 즉, st.session_state.df가 딕셔너리가 된 상태입니다.

  이는 update_data에서 st.session_state.df = st.session_state.editor를 실행했는데, 이때 st.session_state.editor가 딕셔너리였을 가능성이 큽니다. (Streamlit 내부 동작상 변경 사항만 딕셔너리로 저장되는
  경우가 있을 수 있음).

  따라서 안전하게 st.data_editor의 반환값을 사용하는 것이 좋습니다.